# Syncseed - Deployment Guide
Welcome to the Syncseed deployment guide. Included in this file is how the Syncseed algorithm works, and how you can use this algorithm in your own projects.


# Table of Contents

1. [**The Syncseed Algorithm**](#the-syncseed-algorithm)

2. [**Syncseed Configuration Options**](#syncseed-configuration-options)

3. [**Deploying Syncseed**](#deploying-syncseed)


# The Syncseed Algorithm
The Syncseed algorithm at its heart uses the ChaCha CSPRNG with a seed to generate pseudorandom numbers used as response to a server challenge.

In the Syncseed module, the ChaCha generator is automatically set up with an empty seed:
```python
def __init__(self):
        self.new_seed = None
        self.generator = np.random.Generator(ChaCha(seed=self.new_seed, rounds=self.CHA_CHA_GENERATOR_ROUNDS))
```
The generator rounds for the ChaCha generator is set to 20 by default.

The Syncseed algorithm follows a 5-step process for authentication, let's break down how it works:
1. The generator is initiated with a seed. This generator is used in the `get_expected_seed_value()` function.
```python
self.generator = np.random.Generator(ChaCha(seed=seed, rounds=self.CHA_CHA_GENERATOR_ROUNDS))
```
2. The generator is then used to generate a tuple of integers. The range of these seeds are defined by the upper and lower bound variable of the SyncseedGenerator class. This tuple is the joined into a string and returned. This string is what is used for authentication, and the client would usually send this string (or its hash) to the server for authentication.
```python
return ''.join(str(
	self.generator.integers(self.SEED_VALUE_LOWER_BOUND, self.SEED_VALUE_UPPER_BOUND, endpoint=True))
	for _ in range(self.CHALLENGE_ROUNDS))
```
An example of an output returned by the `get_expected_seed_value()` function, assuming the user seed is 1234567890:
```python
>>> import syncseed.syncseed as syncseed
>>> gen = syncseed.SyncseedGenerator()
>>> user_seed = 1234567890
>>> gen.get_expected_seed_value(user_seed)
'197544844709682981529929921610932446315360849899229237209555896328868903795463988775840543690416'
>>> # Remember this is used with the default settings, which explains why this string is so long
>>> # I will get into more detail about the above later
```
Notice how if I call this function more than once, I get the same output:
```python
>>> gen.get_expected_seed_value(user_seed)
'197544844709682981529929921610932446315360849899229237209555896328868903795463988775840543690416'
>>> gen.get_expected_seed_value(user_seed)
'197544844709682981529929921610932446315360849899229237209555896328868903795463988775840543690416'
>>> # Of course, if I pass a different seed I would get a different output
>>> gen.get_expected_seed_value(1234)
'348911113624966401274495629418554123983196692321297568434620200691622600117165938154304589726208'
```
3. Once the value generated by `get_expected_seed_value()` (or its hash) is transmitted to the server. Let's assume the server has received this value and is now going to check if the user is authenticated. The server does this with the client's seed (stored server-side) using the `authenticated()` function.
```python
>>> user_seed = 1234567890
>>> seed_value = gen.get_expected_seed_value(user_seed)
>>> gen.authenticated(seed_value, user_seed)
True
>>> other_seed_value = gen.get_expected_seed_value(1234)
>>> gen.authenticated(other_seed_value, user_seed)
False
```
4. If the user is successfully authenticated, both the client and server will update their stored seed values using the `update_seed()` function as shown. Remember, the updated seed is not transmitted, both the server and client already have the seed, they simply call this function:
```python
>>> user_seed =  1234567890
>>> # Remember to call a function which uses the seed to ensure that the generator knows which seed you are dealing with
>>> gen.get_expected_seed_value(user_seed)
'197544844709682981529929921610932446315360849899229237209555896328868903795463988775840543690416'
>>> gen.update_seed()
261769716932103733
>>> # This is our new seed, which can be stored for later use
```
5. This process is then repeated for every authentication attempt. A new seed is generated with each connection without the transfer of the seed or any information relating to it. This process is even more secure if the hash of the seed is compared instead of using the `authenticated()` function. As a result, we have a efficient and secure authentication system.
```python
>>> user_seed =  1234567890
>>> gen.get_expected_seed_value(user_seed)
'197544844709682981529929921610932446315360849899229237209555896328868903795463988775840543690416'
>>> user_seed = gen.update_seed()
261769716932103733
>>> gen.get_expected_seed_value(user_seed)
'263995192298263643671824437871080108312061412385264528125727562894496855378402648457599510005404'
```
# Syncseed Configuration Options
In this section I will go over what each property of the Syncseed generator does, one-by-one.
1. `seed_length`

This property sets the length for each seed. For example, with a seed length of 4, the seed would be a 4-digit number between 1000 and 9999. Similarly, a seed length of 5 would imply a seed between 10000 and 99999. Be default, the seed length is set to 18, which is the maximum seed length allowed by the Syncseed generator.

2. `challenge_rounds`

This configuration option will set a parameter called `challenge_rounds` to any positive integer. Essentially, this parameter controls how many integers are produced by `get_expected_seed_value()`. For instance, if a number was generated between 10 and 20 with `challenge_rounds` set to 4, the generator could produce 13, 18, 19 and 11. The generator would the combine all these values into one string: '13181911'. This string is what is used to authenticate the user.

3. `scramble_rounds`

This configuration option will set a parameter called `scramble_rounds` to any positive integer. Under the `update_seed()`function, the seed is used to generate a new seed depending on how Syncseed is configured:
```python
def update_seed(self) -> int:
  self.__new_seed = self.generator.integers(10 ** (self.seed_length - 1), 10 ** self.seed_length)

  for _ in range(self.scramble_rounds+1):
    self.generator = np.random.Generator(ChaCha(seed=self.__new_seed, rounds=self.cha_cha_generator_rounds))
    self.__new_seed = self.generator.integers(10 ** (self.seed_length - 1), 10 ** self.seed_length)

  return self.__new_seed
```
Assuming our current seed is 35 and our seed length is 2. We can see that the generator would generate a new seed using the current generator (with a seed of 35). Let's say this generator then produces 61 as the new seed. Now, with `scramble_rounds` set to 2, this new seed is then used to set up another generator with a seed of 61. The new generator is then used to produce yet another 2-digit seed, let's say this value is 45. This process of repeatedly updating the seed is repeated for n+1 times, where n is the value of `scramble_rounds`.

4. `seed_value_lower_bound` and `seed_value_upper_bound`

These options are straightforward. They set the upper and lower bounds for the values generated by the `get_expected_seed_value()` function.

5. `cha_cha_generator_rounds`

This option sets the generator rounds within the ChaCha generator used in Syncseed. Usually, a value of 12 should suffice. However, due to it's minimal performance impact, this value has been set to 20 by default. For more information, see [Randomgen's page on ChaCha](https://bashtage.github.io/randomgen/bit_generators/chacha.html).

# SEA (Syncseed Exchange Algorithm)
SEA takes advantage of a centralized Trusted Authority (TA), which has knowledge of the seeds of two users. Let's assume these two users are user 1 and user 2 respectively.

Let's assume user 1's seed is 12 and user 2's seed is 73
```python
>>> user1_seed = 12345678
>>> user2_seed = 87654321
>>> import syncseed.seed_exchange as seed_exchange
>>> sea = seed_exchange.SyncseedExchangeAlgorithm()
>>> sea.seed_length = 8 # Make sure this is the same length as user seeds
```
Now, user 1 and user 2 send a request to the Trusted Authority (TU), requesting a synchronized seed for the both of them. The TU then returns transformations to user 1 and user 2 to transform their seeds into a different one. There are 3 methods this exchange can take place:

1. [**Parity Transformation**](#parity-transformation)
2. [**Exchange Transformation**](#exchange-transformation)
3. [**Selection Transformation**](#selection-transformation)

## 1. Parity Transformation

The Parity Transformation method performs a bitwise XOR operation on the seeds and nonces to generate transformations. This method ensures a secure exchange of seeds without directly transmitting them, as the final seed will be neither user's seed, instead a third hidden seed created by the TA.

### Usage

```python
>>> transformation_user1, transformation_user2 = sea.parity_transformation(user1_seed, user2_seed)
>>> sea.extract_parity(user1_seed, transformation_user1) # See how we end up with a different seed?
58493659
>>> sea.extract_parity(user2_seed, transformation_user2)
58493659
```

## 2. Exchange Transformation

### Description

The Exchange Transformation method performs a bitwise XOR operation on the seeds and nonces. This transformation will cause both users to end up exchanging seeds. This way, both users can authenticate each other using each other's seeds.

### Usage

```python
>>> transformation_user1, transformation_user2 = sea.exchange_transformation(user1_seed, user2_seed)
>>> sea.extract_parity(user1_seed, transformation_user1)
87654321
>>> sea.extract_parity(user2_seed, transformation_user2)
12345678
```

## 3. Selection Transformation

### Description

The Selection Transformation method involves randomly choosing one seed, updating it using Syncseed, and performing a bitwise XOR operation with nonces. Using this method, the selected seed will be the output extracted at both user ends, and this seed will be the seed that is used for authentication between peers. Through this method, seeds can also be synchronized between two different clients.

### Usage

```python
>>> transformation_user1, transformation_user2 = sea.exchange_transformation(user1_seed, user2_seed)
>>> sea.extract_parity(user1_seed, transformation_user1)
12345678
>>> sea.extract_parity(user2_seed, transformation_user2)
12345678
```

## Additional Configuration

The `SyncseedExchangeAlgorithm` class includes properties for configuring seed length and the number of transformation rounds:

- `seed_length`: Set the desired seed length.
- `transform_rounds`: Set the number of transformation rounds for extracting the seed from parity transformations (optional).
- `mutate = True`: This argument can be used for parity extraction, simply mutating the seed after (optional).

Feel free to experiment with different configurations based on your security requirements.

# Deploying Syncseed

Integrating Syncseed into your system is a straightforward process. By following the deployment steps outlined below, you can seamlessly implement the Syncseed algorithm to safeguard your applications. This section provides a guide to help you successfully deploy Syncseed and leverage its secure authentication capabilities in your projects.

### How do I store user seeds?
It is recommended to store user seeds in a secure database. Due to the nature of seeds and how they have to be used in their raw form, they have to be stored either in plaintext or have to be encrypted. **Seeds can not be hashed.**

### What if seeds are compromised?
Seeds cannot solely be used to authenticate a user. Username and password checks come first. Seeds are also dynamic, and change with every authentication attempt. Seeds can be iterated through states using the servers publicly available configuration for the Syncseed generator, but this is easily combatted with the `mutate_seed()` function included with Syncseed (Consult the readme for more information).

### How does the client know the server configuration?
Simply transmit these details to the client, the server configuration is entirely public, and exposing it does not pose any vulnerabilities as long as periodic seed mutation is practiced.

### What if a client desynchronizes, and can no longer use it's seed to authenticate?
You can fall back on other authentication mechanisms such as manual email verification and standard password reset routines to initiate a seed re-transmission. Another approach would be to use recovery keys, however use this method with caution, and inform all users about the need to keep these keys secure.

### If the seed is never transmitted, how does the client use multiple devices?
Consider setting up a method of session management, where a user can have multiple seeds. For example User-1 can have Device-1 and Device-2 set up as authenticated devices. The username for the devices could be stored as User-1-Device-1 and User-1-Device-2. This way, both devices can have different seed values. User-1 can set up authenticated devices using any device that is already authenticated. Alternatively, you can also require 2-factor authentication from the first ever authenticated device for any additional connection. However, this approach is tedious, and defeats the purpose of Syncseed being a seamless authentication system.

### How do I know how well Syncseed performs?
Consider using the benchmarking tools provided in the `syncseed/tests` folder.

### What are seed exchanges used for?

Seed exchanges can be used for anything from seed synchronization to device synchronization and peer to peer authentication. Feel free to experiment with the module to find out what use case would suit you the best.

### I still have unanswered questions.
Feel free to contact me or raise an issue. Syncseed is an open-source, collaborative project, and your feedback is invaluable!
